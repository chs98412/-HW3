<!doctype html>
<html lang="ko">
<head>
	<meta charset="utf-8" />
	<title>Direct Manipulation of Math Symbols</title>
</head>

<body>
    <script src='https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js' type='text/javascript'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/2.4.6/fabric.min.js" type="text/javascript"></script>
    <script src="math.min.js" type="text/javascript"></script>

    <canvas id="c" width="1024" height="768">
        Canvas not supported
    </canvas>

    <script>
        const parser = math.parser();

        const SYMBOL_WIDTH = 50;
        const SYMBOL_HEIGHT = 50;
        var countTest=0;

        let MathApp = {};

        MathApp.symbol_paths = {
                '+':    "add",
                '-':    "sub",
                '*':    "mul",
                '/':    "div",
                '(':    "parenthesis_open",
                ')':    "parenthesis_close",
                '[':    "squarebracket_open",
                ']':    "squarebracket_close",
                '{':    "curlybrace_open",
                '}':    "curlybrace_close",
                '.':    "period",
                ',':    "comma",
                ':':    "colon",
                ';':    "semicolon",
                '=':    "equal",
                '>':    "more",
                '<':    "less",
                '!':    "exclamation",
                'sin':  "sin",
        };

        MathApp.blocks = [];
        MathApp.buttons=[];
        MathApp.selected_block = null;

        MathApp.is_mouse_dragging = false;       
        MathApp.mouse_drag_prev = {x:0, y:0};

        MathApp.block_types = {
            UNDEFINED:  "undefind",
            SYMBOL:     "symbol",
        };

        MathApp.initialize = function() {
            for(let i=0; i <= 9; i++)
            {
                let key = i.toString();
                let value = key;
                this.symbol_paths[key] = value;
            }

            for(let c="a".charCodeAt(0); c <= "z".charCodeAt(0); c++)
            {
                let key = String.fromCharCode(c);
                let value = key;
                this.symbol_paths[key] = value;
            }

            this.canvas = new fabric.Canvas("c", {
                backgroundColor: "#eee",
                hoverCursor: "default",
                selection: false
            });

            //
            $(document).keypress(function(event) {
                let key = String.fromCharCode(event.which);
                MathApp.handleKeyPress(key);
            });
            $(document).mousedown(function(event) {
                let p = {x: event.pageX, y: event.pageY};
                MathApp.handleMouseDown(p);
            });
            $(document).mouseup(function(event) {
                let p = {x: event.pageX, y: event.pageY};
                MathApp.handleMouseUp(p, MathApp.transformToCanvasCoords(p));
            });
            $(document).mousemove(function(event) {
                let p = {x: event.pageX, y: event.pageY};
                MathApp.handleMouseMove(p);
            });
        }

        MathApp.handleKeyPress = function(key) {

            if (key in this.symbol_paths) 
            {
                let size = {
                    width : SYMBOL_WIDTH,
                    height : SYMBOL_HEIGHT
                };
                let position =  MathApp.getPosXY();

                let new_symbol = new MathApp.Symbol(position, size, key);
            }
        }
        //내가추가한거
        {
        MathApp.getPosXY=function(){
            var x;
            var y;
            x= Math.random() * (this.canvas.width - SYMBOL_WIDTH) + SYMBOL_WIDTH / 2;

            y= Math.random() * (this.canvas.height - 300 - SYMBOL_HEIGHT) + SYMBOL_HEIGHT / 2
         

          {
            //   let x1 = x - SYMBOL_WIDTH / 2;
            //     let y1 = y + SYMBOL_HEIGHT / 2;

            //     let x2 =x + SYMBOL_WIDTH / 2;
            //     let y2 =y + SYMBOL_HEIGHT / 2;

            //     let x3 =x + SYMBOL_WIDTH / 2;
            //     let y3 =y - SYMBOL_HEIGHT / 2;

            //     let x4 =x - SYMBOL_WIDTH / 2;
            //     let y4 =y - SYMBOL_HEIGHT / 2;
            //     let rePos=0;
            //     for (let i = 0; i < this.blocks.length; i++) {
            //         let block = this.blocks[i];

            //         if (
            //             (x1 < block.position.x - block.size.width / 2 ||
            //                 x1 > block.position.x + block.size.width / 2 ||
            //                 y1 < block.position.y - block.size.height / 2 ||
            //                 y1 > block.position.y + block.size.height / 2)
            //             &&
            //             (x2 < block.position.x - block.size.width / 2 ||
            //                 x2 > block.position.x + block.size.width / 2 ||
            //                 y2 < block.position.y - block.size.height / 2 ||
            //                 y2 > block.position.y + block.size.height / 2)
            //             &&
            //             (x3 < block.position.x - block.size.width / 2 ||
            //                 x3 > block.position.x + block.size.width / 2 ||
            //                 y3 < block.position.y - block.size.height / 2 ||
            //                 y3 > block.position.y + block.size.height / 2)
            //             &&
            //             (x4 < block.position.x - block.size.width / 2 ||
            //                 x4 > block.position.x + block.size.width / 2 ||
            //                 y4 < block.position.y - block.size.height / 2 ||
            //                 y4 > block.position.y + block.size.height / 2)
            //         ) {
            //             rePos=1;
                    
            //     }
                
            // }
          }
       return { x, y };
            
        }
      
    }//내가추가한거
        MathApp.handleMouseDown = function(window_p) {

            if(MathApp.isInCanvas(window_p))
            {
                let canvas_p = MathApp.transformToCanvasCoords(window_p);

                if( MathApp.selected_block != null )
                {
                    MathApp.selected_block.onDeselected();
                    MathApp.selected_block = null;
                }

                let block = MathApp.findBlockOn(canvas_p);
                console.log(block);
                if(block != null)
                {
                    MathApp.selected_block = block;
                    MathApp.selected_block.onSelected();
                }

                MathApp.is_mouse_dragging = true;
                MathApp.mouse_drag_prev = canvas_p;

                MathApp.canvas.requestRenderAll();
            }
            else
            {
                MathApp.is_mouse_dragging = false;
                MathApp.mouse_drag_prev = {x:0, y:0};
            }
        }

        MathApp.handleMouseMove = function(window_p) {

            let canvas_p = MathApp.transformToCanvasCoords(window_p);


            if(MathApp.is_mouse_dragging)
            {
                  if(MathApp.selected_block!=null)    {      // 내가 추가한거
                let underblocks=[]
                let notunderblocks=[]
                underblocks= MathApp.findBlockOn2(canvas_p);
                notunderblocks = MathApp.findBlockNotOn(canvas_p);

                if(underblocks!=null){

                for (let i = 0; i < underblocks.length; i++)  {

                    let underblock = underblocks[i];
                   if(underblock.size.width==50){
                    underblock.visual_items[underblock.visual_items.length-1].set({
                        stroke: "rgba(255,0,0,1)"
                    });
                }
                
                      else{
                        underblock.visual_items[0].set({
                            stroke: "rgba(255,0,0,1)"
                        });
                    }
                }}

                if (notunderblocks != null) {
                    for (let i = 0; i < notunderblocks.length; i++) {

                        let notunderblock = notunderblocks[i];
                        notunderblock.visual_items[notunderblock.visual_items.length - 1].set({
                            stroke: "rgba(0,0,255,1)"
                        });
                        notunderblock.visual_items[0].set({
                            stroke: "rgba(0,0,255,1)"
                        });
                    }
                }

               

                      }          //내가 추가한거

                if(MathApp.selected_block != null)
                {
                    let tx = canvas_p.x - MathApp.mouse_drag_prev.x;
                    let ty = canvas_p.y - MathApp.mouse_drag_prev.y;
                    MathApp.selected_block.translate({x: tx, y: ty});
                }
                MathApp.mouse_drag_prev = canvas_p;

                MathApp.canvas.requestRenderAll();
            }
        }
               {     //내가 추가한거
             MathApp.findBlockOn2 = function () {
             


                 let x = MathApp.selected_block.position.x - MathApp.selected_block.size.width/2;
                 let y = MathApp.selected_block.position.y + MathApp.selected_block.size.height/2;

                 let x2 = MathApp.selected_block.position.x + MathApp.selected_block.size.width/2;
                 let y2 = MathApp.selected_block.position.y + MathApp.selected_block.size.height/2;

                 let x3 = MathApp.selected_block.position.x + MathApp.selected_block.size.width/2;
                 let y3 = MathApp.selected_block.position.y - MathApp.selected_block.size.height/2;

                 let x4 = MathApp.selected_block.position.x - MathApp.selected_block.size.width/2;
                 let y4 = MathApp.selected_block.position.y - MathApp.selected_block.size.height/2;
                let underblocks=[];
                for (let i = 0; i < this.blocks.length; i++) {
                    let block = this.blocks[i];

                    if (
                        (x >= block.position.x - SYMBOL_WIDTH/2 &&
                        x <= block.position.x + block.size.width/2 &&
                        y >= block.position.y - block.size.height/2 &&
                        y <= block.position.y + block.size.height/2)
                        ||
                        (x2 >= block.position.x - SYMBOL_WIDTH/2 &&
                        x2 <= block.position.x + block.size.width/2 &&
                        y2 >= block.position.y - block.size.height/2 &&
                        y2 <= block.position.y + block.size.height/2)
                        || 
                        (x3 >= block.position.x - SYMBOL_WIDTH/2 &&
                        x3 <= block.position.x + block.size.width/2 &&
                        y3 >= block.position.y - block.size.height/2 &&
                        y3 <= block.position.y + block.size.height/2)
                        ||
                        (x4 >= block.position.x - SYMBOL_WIDTH/2 &&
                        x4 <= block.position.x + block.size.width/2 &&
                        y4 >= block.position.y - block.size.height/2 &&
                        y4 <= block.position.y + block.size.height/2)
                    )
                         {
                        underblocks.push(block);
                    }
                }
                return underblocks;
              
            }

              MathApp.findBlockNotOn = function () {
                let x = MathApp.selected_block.position.x - SYMBOL_WIDTH / 2;
                  let y = MathApp.selected_block.position.y + MathApp.selected_block.size.height / 2;

                  let x2 = MathApp.selected_block.position.x + MathApp.selected_block.size.width- SYMBOL_WIDTH / 2;
                  let y2 = MathApp.selected_block.position.y + MathApp.selected_block.size.height / 2;

                  let x3 = MathApp.selected_block.position.x + MathApp.selected_block.size.width - SYMBOL_WIDTH / 2;
                  let y3 = MathApp.selected_block.position.y - MathApp.selected_block.size.height / 2;

                  let x4 = MathApp.selected_block.position.x - SYMBOL_WIDTH  / 2;
                  let y4 = MathApp.selected_block.position.y - MathApp.selected_block.size.height / 2;

                    let notunderblocks = [];
                    for (let i = 0; i < this.blocks.length; i++) {
                        let block = this.blocks[i];

                        if (
                            (x < block.position.x - SYMBOL_WIDTH / 2 ||
                            x > block.position.x + block.size.width / 2 ||
                            y < block.position.y - block.size.height / 2 ||
                            y > block.position.y + block.size.height / 2)
                            &&
                            (x2 < block.position.x - SYMBOL_WIDTH / 2 ||
                            x2 > block.position.x + block.size.width / 2 ||
                            y2 < block.position.y - block.size.height / 2 ||
                            y2 > block.position.y + block.size.height / 2)
                            &&
                            (x3 < block.position.x - SYMBOL_WIDTH / 2 ||
                            x3 > block.position.x + block.size.width / 2 ||
                            y3 < block.position.y - block.size.height / 2 ||
                            y3 > block.position.y + block.size.height / 2)
                            &&
                            (x4 < block.position.x - SYMBOL_WIDTH / 2 ||
                            x4 > block.position.x + block.size.width / 2 ||
                            y4 < block.position.y - block.size.height / 2 ||
                            y4 > block.position.y + block.size.height / 2)
                            ) {
                            notunderblocks.push(block);
                        }
                    }
                    return notunderblocks;

                }
             } //내가 추가한거

        MathApp.handleMouseUp = function(window_p,canvas_p) {
        let x_current = canvas_p.x;
            let y_current = canvas_p.y;
            if(MathApp.is_mouse_dragging)
            {
                let canvas_p = MathApp.transformToCanvasCoords(window_p);

             
if(MathApp.selected_block!=null)
            {    //ㄴㅐ가 추가한 코드
                let blockgroup='';
                let names=[];
                let newname="";
                let erase=0;
                let size;
                let position;
                for (let i = 0; i < this.blocks.length; i++) {
                    let block = this.blocks[i];
                    if(block.visual_items[block.visual_items.length - 1].stroke== "rgba(255,0,0,1)" || block.visual_items[0].stroke == "rgba(255,0,0,1)"  )
                    { 
                        if(block!=MathApp.selected_block){
                        erase=1;
                        position = {
                                x: block.position.x,
                                y: block.position.y,
                            };

                            if(x_current<position.x){        //앞쪽에 놓을 때
                                if (block.name.length == 1){
                                    names.push(MathApp.selected_block.name);
                                     for (let j = 0; j < block.name.length; j++) {
                                        names.push(block.name[j]);
                                    }
                                    
                                }
                                else if (block.name.length > 1) {
                                    for (let j = 0; j < block.name.length; j++) {
                                        names.push(block.name[j]);
                                    }
                                }
                                newname += MathApp.selected_block.name;
                                newname += block.name;
                                position = {
                                    x: x_current,
                                    y: y_current,
                                };
                                block.destroy();

                            }

                        else{
                        if(block.name.length==1)
                        names.push(block.name);
                        else if(block.name.length>1){
                            for(let j=0;j<block.name.length;j++){
                                names.push(block.name[j]);
                            }
                        }
                        newname+=block.name;
                        block.destroy();
                       
                      newname += MathApp.selected_block.name;
                                names.push(MathApp.selected_block.name);
                    }
                
                }
                    }

                }
                if(erase==1) {
                    

             size = {
                        width: SYMBOL_WIDTH * names.length,
                        height: SYMBOL_HEIGHT 
                    };
                    
                let new_symbol = new MathApp.Symbol2(position, size,names.length, names,newname);
                MathApp.selected_block.destroy();
                    MathApp.selected_block = null;
                }



        }//내가 추가한거
                MathApp.is_mouse_dragging = false;
                MathApp.mouse_drag_prev = { x: 0, y: 0 };
                MathApp.canvas.requestRenderAll();
            }
        }

        MathApp.transformToCanvasCoords = function(window_p) {
            let rect = MathApp.canvas.getElement().getBoundingClientRect();
            let canvas_p = {
                x : window_p.x - rect.left,
                y : window_p.y - rect.top
            };
            return canvas_p;
        }
        
        MathApp.isInCanvas = function(window_p) {
            let rect = MathApp.canvas.getElement().getBoundingClientRect();
            if( window_p.x >= rect.left && 
                window_p.x < rect.left + rect.width &&
                window_p.y >= rect.top && 
                window_p.y < rect.top + rect.height )
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        MathApp.findBlockOn = function(canvas_p) {
                 console.log(this.blocks);
            let x = canvas_p.x;
            let y = canvas_p.y;

            for(let i=0; i < this.blocks.length; i++)
            {
                let block = this.blocks[i];

                if( x >= block.position.x - (SYMBOL_WIDTH/2) &&
                    x <= block.position.x + (block.size.width- (SYMBOL_WIDTH / 2))&&
                    y >= block.position.y - block.size.height/2 &&
                    y <= block.position.y + block.size.height/2 )
                {
                    return block;
                }               
            }
            return null;
        }

        MathApp.findBtnOn = function (canvas_p) {
                let x = canvas_p.x;
                let y = canvas_p.y;

                for (let i = 0; i < this.buttons.length; i++) {
                    let button = this.buttons[i];

                    if (x >= button.position.x - (SYMBOL_WIDTH / 2) &&
                        x <= button.position.x + (button.size.width - (SYMBOL_WIDTH / 2)) &&
                        y >= button.position.y - button.size.height / 2 &&
                        y <= button.position.y + button.size.height / 2) {
                        return button;
                    }
                }
                return null;
            }
    MathApp.Buttons = function (position, size) {
        this.position = position;
        this.size = size;
        this.type = MathApp.block_types.UNDEFINED;

        this.visual_items = [];

        MathApp.buttons.push(this);
    }
     MathApp.Buttons.prototype.onSelected = function () {
        console.log("!!!!!1");    
        }

        
        //
        MathApp.Block = function(position, size) {
            this.position = position;
            this.size = size;
            this.type = MathApp.block_types.UNDEFINED;

            this.visual_items = [];

            MathApp.blocks.push(this);
        }

        MathApp.Block.prototype.onDeselected = function() {
           
            if (this.size.width == 50) {
                this.visual_items[this.visual_items.length - 1].set({
                    stroke: "rgba(0,0,255,1)"
                });
            }
            else {
                this.visual_items[0].set({
                    stroke: "rgba(0,0,255,1)"
                });
            }
        }

        MathApp.Block.prototype.onSelected = function() {
            if(this.size.width==50){
            this.visual_items[this.visual_items.length-1].set({
                stroke: "rgba(255,0,0,1)"
            });}
            else {
                this.visual_items[0].set({
                    stroke: "rgba(255,0,0,1)"
                });
            }

            this.visual_items.forEach(item => {
                MathApp.canvas.bringToFront(item);
            });
        }

        MathApp.Block.prototype.moveTo = function(p) {
            let tx = p.x - this.position.x;
            let ty = p.y - this.position.y;

            this.translate({x: tx, y: ty});
        }

        MathApp.Block.prototype.translate = function(v) {
            this.position.x += v.x;
            this.position.y += v.y;

            this.visual_items.forEach(item => {
                item.left += v.x;
                item.top += v.y;
            });
        }

        MathApp.Block.prototype.destroy = function() {
            if(this == MathApp.selected_block)
            {
                MathApp.selected_block = null;
                this.onDeselected();
            }

            this.visual_items.forEach(item => {
                MathApp.canvas.remove(item);
            });
            this.visual_items = [];
            
            let index = MathApp.blocks.indexOf(this);
            if(index > -1)
            {
                MathApp.blocks.splice(index, 1);
            }
        }

           MathApp.Symbol = function (position, size, name) {
                MathApp.Block.call(this, position, size);
                this.type = MathApp.block_types.SYMBOL;
                this.name = name;

                let block = this;

                if (name in MathApp.symbol_paths) {
                    let path = MathApp.symbol_paths[name] + ".jpg";
                    fabric.Image.fromURL(path, function (img) {
                        // (0) Background
                        let background = new fabric.Rect({
                            left: position.x - size.width / 2,
                            top: position.y - size.height / 2,
                            width: size.width,
                            height: size.height,
                            fill: "rgba(255,255,255,1)",
                            stroke: "rgba(0,0,0,0)",
                            selectable: false
                        });

                        // (1) Image
                        img.scaleToWidth(size.width);
                        img.scaleToHeight(size.height);

                        let img_w = img.getScaledWidth();
                        let img_h = img.getScaledHeight();

                        img.set({
                            left: position.x - img_w / 2,
                            top: position.y - img_h / 2,
                            selectable: false
                        });

                        // (2) Boundary
                        let boundary = new fabric.Rect({
                            left: position.x - size.width / 2,
                            top: position.y - size.height / 2,
                            width: size.width,
                            height: size.height,
                            fill: "rgba(0,0,0,0)",
                            stroke: "rgba(0,0,255,1)",
                            strokeWidth: 5,
                            selectable: false
                        });

                        //
                        MathApp.canvas.add(background);
                        MathApp.canvas.add(img);
                        MathApp.canvas.add(boundary);

                        //
                        block.visual_items.push(background);
                        block.visual_items.push(img);
                        block.visual_items.push(boundary);
                    });
                }
            }

            MathApp.Symbol.prototype = Object.create(MathApp.Block.prototype);
        

        //
        MathApp.Symbol2 = function(position, size,count, namegroup,newnames) {
            MathApp.Block.call(this, position, size);
            this.type = MathApp.block_types.SYMBOL2;
            this.name=newnames;
        
            let block = this;

                var q;
                var setleft;
              
                namegroup.forEach((A,B)=>{
                let path = MathApp.symbol_paths[A] + ".jpg";
                fabric.Image.fromURL(path, function(img) {
                    // (0) Background
                    let size_back={width:size.width/count,height: size.height}
                    let background = new fabric.Rect({
                        left: position.x - size_back.width/2 + (B * size_back.width),
                        top: position.y - size_back.height/2 ,
                        width: size_back.width,
                        height: size_back.height,
                        fill: "rgba(255,255,255,1)",
                        stroke: "rgba(0,0,0,0)",
                        selectable: false
                    });

                    // (1) Image 
                    img.scaleToWidth(size_back.width);
                    img.scaleToHeight(size_back.height);

                    let img_w = img.getScaledWidth();
                    let img_h = img.getScaledHeight();

                    img.set({
                        left: position.x - img_w/2+(B*size_back.width),
                        top: position.y - img_h/2,
                        selectable: false
                    });
                 MathApp.canvas.add(background);
                    MathApp.canvas.add(img);
                     block.visual_items.push(background);
                    block.visual_items.push(img);
                                
                  let boundary = new fabric.Rect({
                        left: position.x - size_back.width / 2+ (B * size_back.width),
                        top: position.y - size_back.height / 2,
                        width: size_back.width,
                        height: size_back.height,
                        fill: "rgba(0,0,0,0)",
                        stroke: "rgba(0,0,255,1)",
                        strokeWidth: 2,
                        selectable: false
                    });

                    //

                    MathApp.canvas.add(boundary);

                    //

                    block.visual_items.push(boundary);
                
                });
                    


                            });
                            
            let boundaryMain = new fabric.Rect({
                left: position.x - size.width / count / 2 - 2,
                top: position.y - size.height / 2 - 2,
                width: size.width,
                height: size.height,
                fill: "rgba(0,0,0,0)",
                stroke: "rgba(0,345,215,1)",
                strokeWidth: 7,
                selectable: false
            });

            //

            MathApp.canvas.add(boundaryMain);

            //

            block.visual_items.push(boundaryMain);

                    // (2) Boundary
                  
            }
        

        MathApp.Symbol2.prototype = Object.create(MathApp.Block.prototype);
        



    MathApp.Symbol3 = function (position, size, name) {
        MathApp.Buttons.call(this, position, size);
        this.type = MathApp.block_types.SYMBOL;
        this.name = name;

        let button = this;


                // (2) Boundary
                let boundary = new fabric.Rect({
                    left: position.x - size.width / 2,
                    top: position.y - size.height / 2,
                    width: size.width,
                    height: size.height,
                    fill: "rgba(0,0,0,0)",
                    stroke: "rgba(0,0,255,1)",
                    strokeWidth: 5,
                    selectable: false
                });

                //
            

               
                button.visual_items.push(boundary);
          
        
    }

    MathApp.Symbol3.prototype = Object.create(MathApp.Buttons.prototype);
    MathApp.Symbol({x:100,y:500}, 50, "a");

        //
        $(document).ready(function() {
            MathApp.initialize();
        });
    </script> 
    
</body>
</html>

